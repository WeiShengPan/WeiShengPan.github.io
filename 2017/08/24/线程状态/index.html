<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 线程状态 · Pan</title><meta name="description" content="线程状态 - Weisheng Pan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Pan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/categories" target="_self" class="nav-list-link">CATEGORIES</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="https://github.com/WeiShengPan" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">线程状态</h1><div class="post-info">Aug 24, 2017</div><div class="post-content"><p>一个线程可以处于<strong>新建、就绪、阻塞、死亡</strong>四种状态之一。</p>
<ol>
<li>新建（new）:当线程被创建时，会短暂处于这种状态。此    时已经分配了必须的系统资源，并执行了初始化操作。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为就绪(Runnable)状态或阻塞(Blocked)状态。</li>
<li>就绪（Runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行，这不同于死亡（Dead）和阻塞(Blocked)状态。<a id="more"></a></li>
<li>阻塞（Blocked）：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略该线程，不会分配CPU时间片。直到线程重新进入就绪（Runnable）状态，它才有可能执行操作。</li>
<li>死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间片，它的任务已经结束或不再可运行。任务死亡的通常方式时run（）方法返回，但是任务的线程还可以被中断。</li>
</ol>
<h4 id="进入阻塞状态"><a href="#进入阻塞状态" class="headerlink" title="进入阻塞状态"></a>进入阻塞状态</h4><p>一个任务进入阻塞状态可能有一下原因：</p>
<ul>
<li>通过调用sleep（）使线程进入休眠状态，这种情况下，线程在指定时间内阻塞不会运行。</li>
<li>通过调用wait（）使线程挂起，这种情况下，直到线程得到notify（）或notifyAll（）消息，线程才会进入就绪（Runnable）状态。</li>
<li>线程在等待某个输入/输出完成</li>
<li>线程试图在某个同步对象上调用其同步控制方法，但是另一个线程已经获取该对象锁导致对象锁不可用。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/23/[JAVA]Java类型互转/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Weisheng Pan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>